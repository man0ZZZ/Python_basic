# -*- coding: utf-8 -*-
"""EDA_IMDBtop1000_casestudy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aR_cOAACn5t3vGVbBRJ5luPJOMQ7H2Cx

pick box office data. analyze on your own ..purely EDA,,
problem : perfrom eda on it... find filtering mergigng group by sorting
eg; see all the movies of 'x' directors
eg; see horror movies
task 1.. find all movies from x director
task 2..
task 3.. find all the movies where director 'x' and heros was 'y'
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/gdrive')

df=pd.read_csv('/content/gdrive/MyDrive/BDS_practice_data/IMDB top 1000.csv')
df.head(10)

"""Total number of movies based on certificate. The data type of the value_counts() function returns series"""

df.Certificate.value_counts()

df.Certificate.value_counts().head(11)

"""Total count of unique genre"""

df.Genre.value_counts()

"""Perform nan analysis"""

df.isna()

df.isna().sum()

"""replace certificate nan values with the most frequent one"""

df.Certificate.mode()

print(type(df.Certificate.mode()))

"""get the value from the series returned by mode() function"""

df.Certificate.mode().iloc[0]

df.Certificate.fillna(df.Certificate.mode().iloc[0], inplace=True)

df.Certificate.isna().sum()

#or could be directly replaced with whatever the value of mode is:
df.Certificate.fillna('R',inplace=True)
df.Certificate.isna().sum()

"""replace metascore nan values with the mean"""

df.Metascore.fillna(df.Metascore.mean(), inplace=True)
df.Metascore.isna().sum()

df

"""Notice on the duration column there is minute, transform it into integers only"""

df.Duration.dtypes

duration= lambda x: int(x[:-4])
df_duration = df.Duration.apply(duration)
df_duration

"""using for loop instead"""

dur=[]
for i in df.Duration:
  dur.append(int(i[:-4]))
df.Duration=dur

df.Duration.dtypes

"""Print statistics of all the numeric columns"""

df.Duration.describe()

df.describe(include='all')

"""groupby function
groupby certificate and then see mean value for metascore
"""

df.groupby('Certificate').Metascore.mean()

""" group together two different column means eg in above include Rate column as well??"""

df_metascore=df.groupby('Certificate').Metascore.mean()
df_rate=df.groupby('Certificate').Rate.mean()
df_duration=df.groupby('Certificate').Duration.mean()
print(df_metascore)
print(df_rate)
print(df_duration)

"""combine two series into a dataframe??"""

df_mean=pd.DataFrame({'Metascore':df_metascore,'Rate':df_rate,'Duration':df_duration})
df_mean

"""Info column has data for VOtes and Gross revenue. Now, try to extract the data and make two separate column for votes and gross revenue in the original data frame"""

df.Info

print(type(df.Info[0]))
df.Info[0]

"""Break the info column into Votes and Gross"""

votes=[]
gross=[]
for i in range(len(df.Info)):
  lst=df.Info[i].split(' | ')
  print(lst)
  if len(lst)==1:
    lst.append(np.nan)
    votes.append(lst[0])
    gross.append(lst[1])
  else:
    votes.append(lst[0])
    gross.append(lst[1])
#print(len(votes))
#print(len(gross))
df['Votes']=votes
df['Gross']=gross

df

df.Votes[0:10]

modifier=lambda x: int(x[7:].replace(',',''))
df.Votes=df.Votes.apply(modifier)
df

df.Gross.isna().sum()

"""FOr the Gross column, there are nan values. So, transforming the values by subscripting as above won't work.

can use the simple imputer from sklearn, but can only apply most_frequent strategy as the values are in string. If we want to substitute the mean for nan value, we can't use simple imputer
"""

# from sklearn.impute import SimpleImputer
# Imputer=SimpleImputer(strategy='most_frequent', missing_values=np.nan)
# Imputer.fit(df_gross)
# df2_gross=Imputer.transform(df_gross)

# df.Gross=df2_gross

gross_modifier = lambda x: float(x[8:-1]) ## Won't work if there is Nan vlaues, so first replaced nan with the most frequent one and then did the subscripting
df.Gross=df.Gross.apply(gross_modifier)
df.Gross[0:19]

# print(type(df.Votes[0]))
# df.Votes[0]
# vote=[]
# for k in range(len(df.Votes)):
#   for i in df.Votes[k]:
#     num=[]
#     if i.isnumeric():
#       ind=df.Votes[k].index(i)
#       num.append(int(df.Votes[k][ind:])) # Error because there is commas as the thousands separator and int function cannot deal with nonnumeric values
#       break
#   vote.append(num[0])

type(df.Gross[0])

df.Gross[0].isna()

"""correct way around this error is to subscripting the index from the series obtained after df.Gross.isna()"""

df.Gross.isna()[999]

print(type(df.Gross[0]))
print(df.Gross[0])
gross=[]
for k in range(len(df.Gross)):
  if df.Gross[k].isna(): #we can't check the individual value for na if the values are string.
  #instead we subscript the isna series to get our required value as a workaround for checking nan value for string
    gross.append(np.nan)
  else:
    for i in df.Gross[k]:
      num=[]
      if i.isnumeric():
        ind=df.Gross[k].index(i)
        num.append(float(df.Gross[k][ind:-1]))
        break
    gross.append(num[0])
print(type(gross[0]))

print(type(df.Gross[0]))
print(df.Gross[0])
gross=[]
for k in range(len(df.Gross)):
  if df.Gross.isna()[k]: #we can't check the individual value for na if the values are string.
  #instead we subscript the isna series to get our required value as a workaround for checking nan value for string
    gross.append(np.nan)
  else:
    for i in df.Gross[k]:
      num=[]
      if i.isnumeric():
        ind=df.Gross[k].index(i)
        num.append(float(df.Gross[k][ind:-1]))
        break
    gross.append(num[0])
print(type(gross[0]))

df.Gross=gross

"""Now, we are able to replace the nan values in the Gross column with the mean"""

df.Gross=df.Gross.fillna(df.Gross.mean())

df

"""Q. how many films directed by Steven Speilberg is in imdb top1000?

Q. How many films in Imdb top 1000 has featured Matt Damon as a star?
"""

df.Cast[789]

"""Transfer the Cast column to Director column and Stars column"""

director=[]
stars=[]
for i in df.Cast:
  cast=i.split(' | ')
  director.append(cast[0][10:])
  stars.append(cast[1][7:].split(', '))
  
print(len(director))
print(len(stars))



df['Director']=director
df['Stars']=stars
df.head(50)

df.Director.value_counts().loc['Steven Spielberg']

(df.Stars[0])

def stars_movie_in_top1000(name):
  count=0
  for i in df.Stars:
    for j in i:
      if j==name:
        count=count+1
  print(count)

name=str(input('name of the star: '))
stars_movie_in_top1000(name)